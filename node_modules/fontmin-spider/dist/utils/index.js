"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.removeParam = exports.getHash = exports.backup = exports.getUrls = exports.getQuoteless = exports.getAbsolutePath = void 0;
const crypto_1 = __importDefault(require("crypto"));
const path_1 = require("path");
const fs_1 = require("fs");
/**
 * get Absolute Path
 * @param { string } basePath You can think of it as the root of the website
 * @param { string } improtPath import file path
 * @param { string } sourcePath improtPath improt source path
 * @returns { string } absolute path
 */
function getAbsolutePath(basePath, improtPath, sourcePath) {
    return (0, path_1.isAbsolute)(sourcePath) ? (0, path_1.join)(basePath, sourcePath) : (0, path_1.join)((0, path_1.parse)(improtPath).dir, sourcePath);
}
exports.getAbsolutePath = getAbsolutePath;
/**
 * Remove paired single or double quotes
 * @param { string } str You need to remove pairs of single - or double-quoted strings
 * @returns { string } Dispose of paired single- or double-quoted strings
 */
const getQuoteless = (str) => str.replace(/(['"])(.+)\1/g, '$2');
exports.getQuoteless = getQuoteless;
/**
 * Get the resource referenced by url() in css
 * @param { string } value css property value
 * @returns { string[] } Content in url() after processing
 */
function getUrls(value) {
    const reg = /url\((\s*)(['"]?)(.+?)\2(\s*)\)/g;
    let match;
    const urls = [];
    while ((match = reg.exec(value)) !== null) {
        const meta = {
            source: match[0],
            before: match[1],
            quote: match[2],
            value: match[3],
            after: match[4]
        };
        if (meta.value.indexOf('data:') !== 0 || meta.value.indexOf('#') !== 0) {
            urls.push(meta);
        }
    }
    return urls;
}
exports.getUrls = getUrls;
const BACKUP = '.backup';
/**
 * File Backup
 * @param { string } filePath Need to backup file
 * @returns { string } File path after backup
 */
function backup(filePath) {
    const { dir, name, ext } = (0, path_1.parse)(filePath);
    const backupPath = (0, path_1.join)(dir, name) + BACKUP + ext;
    if ((0, fs_1.existsSync)(backupPath))
        return backupPath;
    (0, fs_1.copyFileSync)(filePath, backupPath);
    return backupPath;
}
exports.backup = backup;
/**
 * Generate hash
 * @param { string | buffer } data Generate the contents of the hash
 * @param { number } size The size (length) of the generated hash
 * @returns { string } hash
 */
function getHash(data, size = 10) {
    if (typeof data !== 'string' && !Buffer.isBuffer(data)) {
        throw new TypeError('Expected a Buffer or string');
    }
    size = Number.isInteger(size) ? size : 10;
    const md5 = crypto_1.default.createHash('md5').update(data).digest('hex');
    return size > md5.length ? md5 : md5.slice(0, size);
}
exports.getHash = getHash;
/**
 * 移除参数以及锚点
 * @param { string } param string
 * @returns { string } string
 */
const removeParam = (param) => param.replace(/#.*$/, '').replace(/\?.*$/, '');
exports.removeParam = removeParam;
