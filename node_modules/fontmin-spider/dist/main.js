"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.spider = exports.parse = void 0;
const promises_1 = require("node:fs/promises");
const fast_glob_1 = __importDefault(require("fast-glob"));
const fontmin_1 = __importDefault(require("fontmin"));
const parse_1 = __importDefault(require("./parse"));
const utils_1 = require("./utils");
var parse_2 = require("./parse");
Object.defineProperty(exports, "parse", { enumerable: true, get: function () { return __importDefault(parse_2).default; } });
/**
 * Crawl the fonts referenced by the specified .html file for compression.
 * matching the text used according to the css selector, compressing on demand
 * @param options
 * @param { string } options.basePath You can think of it as the root of the website
 * @param { string | string[] } options.source https://github.com/mrmlnc/fast-glob#patterns
 * @param { boolean } options.backup backup font (font.backup.ttf) (default: true)
 * @param { string | object } options.reserveText
 * Reserved text. For example, when using JavaScript to add text dynamically.
 * the fontmin-spider will not be able to parse the text and you will need to add the reserved text manually
 * @param { string[] } options.ignore Ignore html file. https://github.com/mrmlnc/fast-glob#ignore
 * @param { Function } options.filter Execute when all the used fonts are parsed
 * (the strings are not parsed, you can use the afterFilter method if you need to process the strings)
 * @param { Function } options.afterFilter After parsing is complete, execute
 */
function spider(options) {
    const fgOptions = { dot: true, absolute: true, cwd: options.basePath, ignore: options.ignore };
    options.backup = options.backup === false ? false : true;
    const files = fast_glob_1.default.sync(options.source || '**/*.html', fgOptions);
    const fontMaps = (0, parse_1.default)(options.basePath, files, options.filter, options.afterFilter);
    return Promise.all(Object.entries(fontMaps).map(([name, font]) => {
        return new Promise((resolve, reject) => {
            if (!font)
                return resolve(null);
            if (typeof options.reserveText === 'string') {
                font.chars += options.reserveText;
            }
            else if (Object.prototype.toString.call(options.reserveText) === '[object Object]') {
                // eslint-disable-next-line @typescript-eslint/no-explicit-any
                const reserveText = options.reserveText[name];
                if (reserveText)
                    font.chars += reserveText;
            }
            if (!font.chars)
                return resolve(null);
            const path = font.path;
            if (options.backup)
                font.path = (0, utils_1.backup)(font.path);
            const fontmin = new fontmin_1.default().src(font.path);
            fontmin.use(fontmin_1.default.glyph({ text: font.chars, hinting: false }));
            fontmin.run((err, file) => __awaiter(this, void 0, void 0, function* () {
                if (err)
                    return reject(err);
                (0, promises_1.writeFile)(path, file[0]._contents).then(resolve, reject);
            }));
        });
    }));
}
exports.spider = spider;
